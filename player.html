<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>드로잉 배틀 — 참가자용(Player) v6 · 날짜/주가 축라벨+되돌리기</title>
<style>
 body{font-family:system-ui,Apple SD Gothic Neo,Segoe UI,Roboto,Malgun Gothic,sans-serif;margin:0;background:#0b1220;color:#e8eef9}
 header{padding:14px 18px;background:#0f172a;border-bottom:1px solid #22324a}
 h1{font-size:18px;margin:0}
 .wrap{display:grid;grid-template-columns:320px 1fr;gap:14px;padding:14px}
 .card{background:#0f172a;border:1px solid #22324a;border-radius:14px;padding:14px}
 label{display:block;font-size:13px;margin:8px 0 4px;color:#9fb3cf}
 input,textarea,button{width:100%;padding:10px;border-radius:10px;border:1px solid #2b3d62;background:#0b1220;color:#e8eef9}
 textarea{min-height:96px}
 button{cursor:pointer}
 canvas{background:#0b1220;border:1px dashed #324769;border-radius:12px;touch-action:none}
 .pill{display:inline-block;padding:4px 10px;border:1px solid #2b3d62;border-radius:999px;font-size:12px;margin-right:6px}
 .muted{color:#9bb0cf;font-size:12px}
 .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
 .ok{color:#86efac}
 .danger{color:#ff9aa2}
 .big{font-size:22px}
 .lock{color:#fbbf24}
 .hint{font-size:12px;color:#9bb0cf;margin-top:6px}
 .kbd{font-family:ui-monospace,Menlo,Consolas,monospace;border:1px solid #2b3d62;border-radius:6px;padding:2px 6px;font-size:12px}
</style>
</head>
<body>
<header>
  <h1>드로잉 배틀 — 참가자용(Player) v6 · 날짜/주가 축라벨+되돌리기</h1>
</header>
<div class="wrap">
  <aside class="card">
    <h3 style="margin:0 0 6px">1) 라운드 참가</h3>
    <label>조/팀 이름</label>
    <input id="team" placeholder="예: A조" />
    <label>라운드 코드 붙여넣기 (또는 QR 링크로 자동 채움)</label>
    <textarea id="code" placeholder="여기에 코드를 붙여넣거나, URL에 ?code= 를 사용하세요"></textarea>
    <button id="btnJoin">참가하기</button>
    <div id="status" class="muted" style="margin-top:8px">코드를 붙여넣고 참가를 누르세요.</div>
    <div class="hint">URL 예: <code>player.html?code=...&team=A%EC%A1%B0</code> 로 접속하면 자동 참가됩니다.</div>
    <hr style="border:none;border-top:1px solid #22324a;margin:14px 0"/>

    <h3 style="margin:0 0 6px">2) 제출</h3>
    <button id="btnSubmit" disabled>제출 파일 저장(JSON)</button>
    <div class="muted">종료 후 자동 잠금됩니다. <b>같은 팀명은 한 번만 제출</b>할 수 있습니다.</div>
  </aside>

  <main class="card">
    <div class="row" style="justify-content:space-between;margin-bottom:8px">
      <div>
        <div class="big">우측 영역에 곡선을 그리세요 (좌측은 힌트)</div>
        <div class="muted" style="margin-top:4px">단축키: <span class="kbd">Ctrl/⌘ + Z</span> 되돌리기 · <span class="kbd">Ctrl/⌘ + Shift + Z</span> 다시하기 · <span class="kbd">R</span> 전체 지우기</div>
      </div>
      <div id="timer" class="pill">대기중</div>
    </div>
    <canvas id="cv" width="1000" height="540"></canvas>
    <div class="row" style="margin-top:10px">
      <button id="btnUndo">되돌리기 (Undo)</button>
      <button id="btnRedo">다시하기 (Redo)</button>
      <button id="btnClear">전체 지우기 (Reset)</button>
    </div>
    <div class="muted" style="margin-top:8px">정답(전체 곡선)은 참가자 화면에 표시되지 않습니다. 종료 시각 이후엔 드로잉이 잠깁니다.</div>
  </main>
</div>

<script>
// --- 유틸 ---
function ub64(s){ return JSON.parse(decodeURIComponent(escape(atob(s)))) }
function qs(k){ const u=new URL(location.href); return u.searchParams.get(k) || null }

let ROUND=null; // {name, startAt, endAt, series, xLabels[], yMin, yMax}
let locked=true; let joined=false; let strokes=[]; let current=null; let storageKey=null;
// undo/redo
let history=[]; let redoStack=[];

const cv=document.getElementById('cv'); const ctx=cv.getContext('2d');
function pxX(u){ return 40+u*(cv.width-80) } function pxY01(v){ const pad=30,h=cv.height-2*pad; return pad+(1-v)*h }

function drawAxes(){
  // grid
  ctx.strokeStyle='#22324a'; ctx.lineWidth=1; for(let i=0;i<=10;i++){ const y=pxY01(i/10); ctx.beginPath(); ctx.moveTo(40,y); ctx.lineTo(cv.width-40,y); ctx.stroke(); }
  if(!ROUND) return;
  // x labels (최대 5개)
  if(ROUND.xLabels && ROUND.xLabels.length){ const pos=[0,0.25,0.5,0.75,1]; ctx.fillStyle='#9bb0cf'; ctx.font='12px sans-serif';
    ROUND.xLabels.forEach((lab,idx)=>{ const x=pxX(pos[idx]|| (idx/(ROUND.xLabels.length-1))); ctx.fillText(lab, x-24, cv.height-8); });
  }
  // y labels (min/mid/max)
  if(Number.isFinite(ROUND.yMin) && Number.isFinite(ROUND.yMax)){
    const yMin=ROUND.yMin, yMax=ROUND.yMax, mid=(yMin+yMax)/2; const arr=[yMin,mid,yMax];
    ctx.fillStyle='#9bb0cf'; ctx.font='12px sans-serif';
    arr.forEach(v=>{ const ratio=(v-yMin)/((yMax-yMin)||1); const y=pxY01(ratio); ctx.fillText(String(Math.round(v)), 6, y+4); });
  }
}

function draw(){
  ctx.clearRect(0,0,cv.width,cv.height);
  drawAxes();
  // hint & user strokes
  if(ROUND){ const N=ROUND.series.length, half=Math.floor(N/2);
    ctx.strokeStyle='#f472b6'; ctx.lineWidth=2; ctx.beginPath(); for(let i=0;i<half;i++){ const u=i/(N-1), x=pxX(u), y=pxY01(ROUND.series[i]); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y) } ctx.stroke();
  }
  ctx.strokeStyle='#60a5fa'; ctx.lineWidth=3; ctx.lineJoin='round'; ctx.lineCap='round';
  strokes.forEach(st=>{ ctx.beginPath(); st.forEach((p,j)=>{ const x=pxX(p.x), y=pxY01(p.y); if(j===0) ctx.moveTo(x,y); else ctx.lineTo(x,y) }); ctx.stroke() })
}

draw();

function pushHistory(){ history.push(JSON.stringify(strokes)); if(history.length>50) history.shift(); redoStack.length=0; }

function startD(e){ if(locked) return; const b=cv.getBoundingClientRect(); const x=(e.touches?e.touches[0].clientX:e.clientX)-b.left; if(x < cv.width/2) return; const y=(e.touches?e.touches[0].clientY:e.clientY)-b.top; const px=(x-40)/(cv.width-80), py=1-(y-30)/(cv.height-60); current=[{x:Math.min(1,Math.max(0.5,px)), y:Math.min(1,Math.max(0,py))}] }
function moveD(e){ if(!current) return; const b=cv.getBoundingClientRect(); const x=(e.touches?e.touches[0].clientX:e.clientX)-b.left; const y=(e.touches?e.touches[0].clientY:e.clientY)-b.top; const px=(x-40)/(cv.width-80), py=1-(y-30)/(cv.height-60); current.push({x:Math.min(1,Math.max(0.5,px)), y:Math.min(1,Math.max(0,py))}); draw() }
function endD(){ if(current){ strokes.push(current); current=null; pushHistory(); draw() } }
cv.addEventListener('mousedown',startD); cv.addEventListener('mousemove',moveD); window.addEventListener('mouseup',endD);
cv.addEventListener('touchstart',startD,{passive:true}); cv.addEventListener('touchmove',moveD,{passive:true}); window.addEventListener('touchend',endD);

// 단축키: Undo/Redo/Reset
window.addEventListener('keydown', (e)=>{
  if(e.target && (e.target.tagName==='INPUT' || e.target.tagName==='TEXTAREA')) return; // 입력창엔 적용 X
  const mod = e.ctrlKey || e.metaKey;
  if(mod && e.key.toLowerCase()==='z'){ e.preventDefault(); if(e.shiftKey) redo(); else undo(); }
  else if(!mod && (e.key==='r' || e.key==='R')){ e.preventDefault(); clearAll(); }
});

function undo(){ if(history.length){ redoStack.push(JSON.stringify(strokes)); strokes = JSON.parse(history.pop()); draw(); } }
function redo(){ if(redoStack.length){ history.push(JSON.stringify(strokes)); strokes = JSON.parse(redoStack.pop()); draw(); } }
function clearAll(){ if(locked) return; strokes=[]; history=[]; redoStack=[]; draw(); }

document.getElementById('btnUndo').addEventListener('click', undo);
document.getElementById('btnRedo').addEventListener('click', redo);
document.getElementById('btnClear').addEventListener('click', clearAll);

const timerEl=document.getElementById('timer'); const statusEl=document.getElementById('status');
function tick(){ if(!ROUND){ timerEl.textContent='대기중'; return; } const now=Date.now(); if(now<ROUND.startAt){ timerEl.textContent='시작까지 '+Math.ceil((ROUND.startAt-now)/1000)+'s'; locked=true; } else if(now<ROUND.endAt){ timerEl.textContent='남은시간 '+Math.ceil((ROUND.endAt-now)/1000)+'s'; locked=false; } else { timerEl.textContent='종료'; locked=true; document.getElementById('btnSubmit').disabled=false; }
  requestAnimationFrame(tick)
}

function joinWith(code, team){
  try{ const r=ub64(code); if(!r || !r.series || !r.endAt || !r.name){ throw 0 }
    ROUND=r; joined=true; const t=(team||document.getElementById('team').value||'team').trim();
    document.getElementById('team').value = t; // 고정
    storageKey = `SUBMIT_LOCK__${r.name}__${t}`;
    if(localStorage.getItem(storageKey)==='1'){
      statusEl.innerHTML = `<span class='lock'>이미 제출된 팀입니다. 재제출 불가</span>`; document.getElementById('btnSubmit').disabled=true; locked=true;
    } else {
      statusEl.innerHTML=`<span class='ok'>참가 완료</span> · 라운드: <b>${r.name}</b>`;
    }
    draw(); tick();
  }catch(e){ alert('코드가 유효하지 않습니다.'); }
}

// 참가 버튼
 document.getElementById('btnJoin').addEventListener('click',()=>{
  const code=document.getElementById('code').value.trim(); if(!code){ alert('라운드 코드를 붙여넣어 주세요.'); return; }
  joinWith(code, document.getElementById('team').value)
 })

// 제출(JSON 저장) — 조당 1회 잠금
function flattenStrokes(ss){ return ss.flat().map(p=>({x:p.x,y:p.y})).filter(p=>p.x>=0.5 && p.x<=1 && p.y>=0 && p.y<=1) }

document.getElementById('btnSubmit').addEventListener('click',()=>{
  if(!joined){ alert('먼저 참가하세요.'); return; }
  if(Date.now()<ROUND.endAt){ alert('아직 제한 시간이 끝나지 않았습니다.'); return; }
  const t=(document.getElementById('team').value||'team').trim();
  if(localStorage.getItem(`SUBMIT_LOCK__${ROUND.name}__${t}`)==='1'){ alert('이미 이 팀에서 제출을 완료했습니다.'); return; }
  const flat=flattenStrokes(strokes);
  if(flat.length<10){ alert('곡선을 더 그려주세요.'); return; }
  const payload={ team:t, meta:{ name:ROUND.name, submittedAt:new Date().toISOString() }, strokes: flat };
  const blob=new Blob([JSON.stringify(payload,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`${t}_${ROUND.name}.json`; a.click(); URL.revokeObjectURL(a.href);
  localStorage.setItem(`SUBMIT_LOCK__${ROUND.name}__${t}`,'1');
  document.getElementById('btnSubmit').disabled=true; statusEl.innerHTML = `<span class='lock'>제출 완료 — 조당 1회 잠금</span>`; locked=true;
})

// --- QR 흐름: URL 파라미터에 code/team 이 있으면 자동 참가 ---
(function autoJoin(){
  const code = qs('code') || (location.hash.startsWith('#code=')? decodeURIComponent(location.hash.slice(6)) : null);
  const team = qs('team');
  if(code){ document.getElementById('code').value = code; if(team) document.getElementById('team').value = team; joinWith(code, team); }
})();

</script>
</body>
</html>